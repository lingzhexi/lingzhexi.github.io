<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1 、什么是 socket我们知道进程通信的方法有管道 、命名管道 、信号 、消息队列 、共享内存 、信号量 ，这些方法都要求通信的两个进程位于同一个主机 。但是如果通信双方不在同一个主机又该如何进行通信呢？ 在计算机网络中我们就学过了 tcp&#x2F;ip 协议族 ，其实使用 tcp&#x2F;ip 协议族就能达到我们想要的效果 ，如下图 （图片来源于 《tcp&#x2F;ip 协议详解卷一》 第一章 1.3）">
<meta name="keywords" content="java、随想、发言地">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP原理及基于Socket编程">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;08&#x2F;02&#x2F;TCP%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9F%BA%E4%BA%8ESocket%E7%BC%96%E7%A8%8B&#x2F;index.html">
<meta property="og:site_name" content="Stormling的博客">
<meta property="og:description" content="1 、什么是 socket我们知道进程通信的方法有管道 、命名管道 、信号 、消息队列 、共享内存 、信号量 ，这些方法都要求通信的两个进程位于同一个主机 。但是如果通信双方不在同一个主机又该如何进行通信呢？ 在计算机网络中我们就学过了 tcp&#x2F;ip 协议族 ，其实使用 tcp&#x2F;ip 协议族就能达到我们想要的效果 ，如下图 （图片来源于 《tcp&#x2F;ip 协议详解卷一》 第一章 1.3）">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160106212015200-534370991.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160106213656075-1895373856.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160106234043965-1905612464.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160107143012543-2040015072.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160107154621246-604295524.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160107184421450-856838651.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160107201721075-1061362000.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160107202442450-451372966.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160107203736371-2068566086.png">
<meta property="og:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160107203757481-2030859869.png">
<meta property="og:updated_time" content="2019-09-03T01:31:24.621Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;images2015.cnblogs.com&#x2F;blog&#x2F;733402&#x2F;201601&#x2F;733402-20160106212015200-534370991.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/02/TCP原理及基于Socket编程/"/>





  <title>TCP原理及基于Socket编程 | Stormling的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bd6695e4140929320b1134247a3b0ffd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Stormling的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">厚积薄发</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/02/TCP%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9F%BA%E4%BA%8ESocket%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormling">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormling的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TCP原理及基于Socket编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-02T17:30:49+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/02/TCP%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9F%BA%E4%BA%8ESocket%E7%BC%96%E7%A8%8B/" class="leancloud_visitors" data-flag-title="TCP原理及基于Socket编程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-、什么是-socket"><a href="#1-、什么是-socket" class="headerlink" title="1 、什么是 socket"></a>1 、什么是 socket</h1><p>我们知道进程通信的方法有管道 、命名管道 、信号 、消息队列 、共享内存 、信号量 ，这些方法都要求通信的两个进程位于同一个主机 。但是如果通信双方不在同一个主机又该如何进行通信呢？ 在计算机网络中我们就学过了 tcp/ip 协议族 ，其实使用 tcp/ip 协议族就能达到我们想要的效果 ，如下图 （图片来源于 《tcp/ip 协议详解卷一》 第一章 1.3）</p>
<p>　　　　　　　　　<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160106212015200-534370991.png" alt=""> 、</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　 图一 各协议所处层次</p>
<p>当然 ，这样做固然是可以的 ，但是 ，当我们使用不同的协议进行通信时就得使用不同的接口 ，还得处理不同协议的各种细节 ，这就增加了开发的难度 ，软件也不易于扩展 。于是 UNIX BSD 就发明了 socket 这种东西 ，socket 屏蔽了各个协议的通信细节 ，使得程序员无需关注协议本身 ，直接使用 socket 提供的接口来进行互联的不同主机间的进程的通信 。这就好比操作系统给我们提供了使用底层硬件功能的系统调用 ，通过系统调用我们可以方便的使用磁盘 （文件操作） ，使用内存 ，而无需自己去进行磁盘读写 ，内存管理 。socket 其实也是一样的东西 ，就是提供了 tcp/ip 协议的抽象 ，对外提供了一套接口 ，同过这个接口就可以统一 、方便的使用 tcp/ip 协议的功能了 。百说不如一图 ，看下面这个图就能明白了 。</p>
<p>　　　　　　　　　<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160106213656075-1895373856.png" alt=""></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图二 socket 所处层次</p>
<p>那么 ，在 BSD UNIX 又是如何实现这层抽象的呢？ 我们知道 unix 中万物皆文件 ，没错 ，bsd 在实现上把 socket 设计成一种文件 ，然后通过虚拟文件系统的操作接口就可以访问 socket ，而访问 socket 时会调用相应的驱动程序 ，从而也就是使用底层协议进行通信 。 （vsf 也就是 unix 提供给我们的面向对象编程 ，如果底层设备是磁盘 ，就对磁盘读写 ，如果底层设备是 socket 就使用底层协议在网中进行通信 ，而对外的接口都是一致的） 。下面再看一下 socket 的结构是怎样的 （图片来源于 《tcp/ip 协议详解卷二》 章节一 ，1.8 描述符） ，注意： 这里的 socket 是一个实例化之后的 socket ，也就是说是一个具体的通信过程中的 socket ，不是指抽象的 socket 结构 ，下文还会进行解释 。</p>
<p>　　　　　　　　　<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160106234043965-1905612464.png" alt=""></p>
<p>　　　　　　　　 　　　　　　　　　　　      图三 udp socket 实例的结构</p>
<p>很明显 ，unix 把 socket 设计成文件 ，通过描述符我们可以定位到具体的 file 结构体 ，file 结构体中有个 f_type 属性 ，标识了文件的类型 ，如图 ，DTYPE_VNODE 表示普通的文件 DTYPE_SOCKET 表示 socket ，当然还有其他的类型 ，比如管道 、设备等 ，这里我们只关心 socket 类型 。如果是 socket 类型 ，那么 f_ops 域指向的就是相应的 socket 类型的驱动 ，而 f_data 域指向了具体的 socket 结构体 ，socket 结构体关键域有 so_type,so_pcb 。so_type 常见的值有：</p>
<ul>
<li>SOCK_STREAM 提供有序的 、可靠的 、双向的和基于连接的字节流服务 ，当使用 Internet 地址族时使用 TCP 。</li>
<li>SOCK_DGRAM 支持无连接的 、不可靠的和使用固定大小 （通常很小） 缓冲区的数据报服务 ，当使用 Internet 地址族使用 UDP 。</li>
<li>SOCK_RAW 原始套接字 ，允许对底层协议如 IP 或 ICMP 进行直接访问 ，可以用于自定义协议的开发 。</li>
</ul>
<p>so_pcb 表示 socket 控制块 ，其又指向一个结构体 ，该结构体包含了当前主机的 ip 地址 (inp_laddr) ，当前主机进程的端口号 (inp_lport) ，发送端主机的 ip 地址 (inp_faddr) ，发送端主体进程的端口号 (inp_fport) 。so_pcb 是 socket 类型的关键结构 ，不亚于进程控制块之于进程 ，在进程中 ，一个 pcb 可以表示一个进程 ，描述了进程的所有信息 ，每个进程有唯一的进程编号 ，该编号就对应 pcb； socket 也同时是这样 ，每个 socket 有一个 so_pcb ，描述了该 socket 的所有信息 ，而每个 socket 有一个编号 ，这个编号就是 socket 描述符 。说到这里 ，我们发现 ，socket 确实和进程很像 ，就像我们把具体的进程看成是程序的一个实例 ，同样我们也可以把具体的 socket 看成是网络通信的一个实例 。</p>
<h1 id="2-、具体-socket-实例如何标识"><a href="#2-、具体-socket-实例如何标识" class="headerlink" title="2 、具体 socket 实例如何标识"></a>2 、具体 socket 实例如何标识</h1><p>我们知道具体的一个文件可以用一个路径来表示 ，比如 / home/zzy/src_code/client.c ，那么具体的 socket 实例我们该如何表示呢 ，其实就是使用上面提到的 so_pcb 的那几个关键属性 ，也就是使用 so_type+ip 地址 + 端口号 。如果我们使用 so_type+ip 地址 + 端口号实例一个 socket ，那么互联网上的其他主机就可以与该 socket 实例进行通信了 。所以下面我们看一下 socket 如何进行实例化 ，看看 socket 给我们提供了哪些接口 ，而我们又该如何组织这些接口</p>
<h1 id="3-、socket-编程接口"><a href="#3-、socket-编程接口" class="headerlink" title="3 、socket 编程接口"></a>3 、socket 编程接口</h1><h2 id="3-1-、socket-接口"><a href="#3-1-、socket-接口" class="headerlink" title="3.1 、socket 接口"></a>3.1 、socket 接口</h2><p>int <strong>socket</strong>(int protofamily, int so_type, int protocol);</p>
<ul>
<li>protofamily 指协议族 ，常见的值有：<br>AF_INET ，指定 so_pcb 中的地址要采用 ipv4 地址类型<br>AF_INET6 ，指定 so_pcb 中的地址要采用 ipv6 的地址类型<br>AF_LOCAL/AF_UNIX ，指定 so_pcb 中的地址要使用绝对路径名<br>当然也还有其他的协议族 ，用到再学习了</li>
<li>so_type 指定 socket 的类型 ，也就是上面讲到的 so_type 字段 ，比较常用的类型有：<br>SOCK_STREAM<br>SOCK_DGRAM<br>SOCK_RAW</li>
<li>protocol 指定具体的协议 ，也就是指定本次通信能接受的数据包的类型和发送数据包的类型 ，常见的值有：<br>IPPROTO_TCP ，TCP 协议<br>IPPROTO_UDP ，UPD 协议<br>0 ，如果指定为 0 ，表示由内核根据 so_type 指定默认的通信协议</li>
</ul>
<p>这里解释一下图三 ，图三其实是使用 AF_INET,SOCK_DGRAM,IPPRTO_UDP 实例化之后的一个具体的 socket 。</p>
<p>那为什么要通过这三个参数来生成一个 socket 描述符？</p>
<p>答案就是通过这三个参数来确定一组固定的操作 。我们说过抽象的 socket 对外提供了一个统一 、方便的接口来进行网络通信 ，但对内核来说 ，每一个接口背后都是及其复杂的 ，同一个接口对应了不同协议 ，而内核有不同的实现 ，幸运的是 ，如果确定了这三个参数 ，那么相应的接口的映射也就确定了 。在实现上 ，BSD 就把 socket 分类描述 ，每一个类别都有进行通信的详细操作 ，分类见下图 。而对 socket 的分类 ，就好比对 unix 设备的分类 ，我们对设备 write 和 read 时 ，底层的驱动是有各个设备自己提供的 ，而 socket 也一样 ，当我们指定不同的 so_type 时 ，底层提供的通信细节也由相应的类别提供 。</p>
<p>　　　　　　　　　　　　　　　　　　<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160107143012543-2040015072.png" alt=""></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图 4 socket 层次图</p>
<p>更详细的 socket （） 函数参数描述请移步：<br><a href="http://blog.csdn.net/liuxingen/article/details/44995467" target="_blank" rel="noopener">http://blog.csdn.net/liuxingen/article/details/44995467</a></p>
<p><a href="http://blog.csdn.net/qiuchangyong/article/details/50099927" target="_blank" rel="noopener">http://blog.csdn.net/qiuchangyong/article/details/50099927</a></p>
<h2 id="3-2-、bind-接口"><a href="#3-2-、bind-接口" class="headerlink" title="3.2 、bind 接口"></a>3.2 、bind 接口</h2><p>int <strong>bind</strong>(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>bind 函数就是给图三种 so_pcb 结构中的地址赋值的接口</p>
<ul>
<li>sockfd   是调用 socket() 函数创建的 socket 描述符</li>
<li>addr     是具体的地址</li>
<li>addrlen  表示 addr 的长度</li>
</ul>
<p>struct sockaddr 其实是 void 的 typedef ，其常见的结构如下图 （图片来源传智播客邢文鹏 linux 系统编程的笔记） ，这也是为什么需要 addrlen 参数的原因 ，不同的地址类型 ，其地址长度不一样：</p>
<p>　　　　　　　　　　　　　　　　　　<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160107154621246-604295524.png" alt=""></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图 5 地址结构图</p>
<ul>
<li>AF_INET:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>AF_INET6:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>AF_UNIX:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span> </span><br><span class="line">    <span class="keyword">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-、connect-接口"><a href="#3-3-、connect-接口" class="headerlink" title="3.3 、connect 接口"></a>3.3 、connect 接口</h2><p>int <strong>connect</strong>(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>这三个参数和 bind 的三个参数类型一直 ，只不过此处 strcut sockaddr 表示对端公开的地址 。三个参数都是传入参数 。connect 顾名思义就是拿来建立连接的函数 ，只有像 tcp 这样面向连接 、提供可靠服务的协议才需要建立连接</p>
<h2 id="3-4-、listen-接口"><a href="#3-4-、listen-接口" class="headerlink" title="3.4 、listen 接口"></a>3.4 、listen 接口</h2><p>int <strong>listen</strong>(int sockfd, int backlog)</p>
<p>告知内核在 sockfd 这个描述符上监听是否有连接到来 ，并设置同时能完成的最大连接数为 backlog 。3.6 节还会继续解释这个参数 。当调用 listen 后 ，内核就会建立两个队列 ，一个 SYN 队列 ，表示接受到请求 ，但未完成三次握手的连接； 另一个是 ACCEPT 队列 ，表示已经完成了三次握手的队列</p>
<ul>
<li>sockfd 是调用 socket() 函数创建的 socket 描述符</li>
<li>backlog 已经完成三次握手而等待 accept 的连接数</li>
</ul>
<p>关于 backlog , man listen 的描述如下：</p>
<ul>
<li>The behavior of the backlog argument on TCP sockets changed with Linux 2.2. Now it specifies the queue length for completely established sockets waiting to be accepted, instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog. When syncookies are enabled there is no logical maximum length and this setting is ignored. See tcp(7) for more information.</li>
<li>If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128. In kernels before 2.4.25, this limit was a hard coded value, SOMAXCONN, with the value 128.</li>
</ul>
<h2 id="3-5-、accept-接口"><a href="#3-5-、accept-接口" class="headerlink" title="3.5 、accept 接口"></a>3.5 、accept 接口</h2><p>int <strong>accept</strong>(int listen_sockfd, struct sockaddr *addr, socklen_t *addrlen)</p>
<p>这三个参数与 bind 的三个参数含义一致 ，不过 ，此处的后两个参数是传出参数 。在使用 listen 函数告知内核监听的描述符后 ，内核就会建立两个队列 ，一个 SYN 队列 ，表示接受到请求 ，但未完成三次握手的连接； 另一个是 ACCEPT 队列 ，表示已经完成了三次握手的队列 。而 accept 函数就是从 ACCEPT 队列中拿一个连接 ，并生成一个新的描述符 ，新的描述符所指向的结构体 so_pcb 中的请求端 ip 地址 、请求端端口将被初始化 。</p>
<p>从上面可以知道 ，accpet 的返回值是一个新的描述符 ，我们姑且称之为 new_sockfd 。那么 new_sockfd 和 listen_sockfd 有和不同呢？ 不同之处就在于 listen_sockfd 所指向的结构体 so_pcb 中的请求端 ip 地址 、请求端端口没有被初始化 ，而 new_sockfd 的这两个属性被初始化了 。</p>
<h2 id="3-6-、listen-、connect-、accept-流程及原理"><a href="#3-6-、listen-、connect-、accept-流程及原理" class="headerlink" title="3.6 、listen 、connect 、accept 流程及原理"></a>3.6 、listen 、connect 、accept 流程及原理</h2><p>以 AF_INET,SOCK_STREAM,IPPROTO_TCP 三个参数实例化的 socket 为例 ，通过一个副图来讲解这三个函数的工作流程及粗浅原理 （图片改自 <a href="http://blog.csdn.net/russell_tao/article/details/9111769" target="_blank" rel="noopener">http://blog.csdn.net/russell_tao/article/details/9111769</a>）</p>
<p>　　　　　　　<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160107184421450-856838651.png" alt=""></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　    图 6 listen 、accept 、connect 流程及原理图</p>
<ol>
<li>服务器端在调用 listen 之后 ，内核会建立两个队列 ，SYN 队列和 ACCEPT 队列 ，其中 ACCPET 队列的长度由 backlog 指定 。</li>
<li>服务器端在调用 accpet 之后 ，将阻塞 ，等待 ACCPT 队列有元素 。</li>
<li>客户端在调用 connect 之后 ，将开始发起 SYN 请求 ，请求与服务器建立连接 ，此时称为第一次握手 。</li>
<li>服务器端在接受到 SYN 请求之后 ，把请求方放入 SYN 队列中 ，并给客户端回复一个确认帧 ACK ，此帧还会携带一个请求与客户端建立连接的请求标志 ，也就是 SYN ，这称为第二次握手</li>
<li>客户端收到 SYN+ACK 帧后 ，connect 返回 ，并发送确认建立连接帧 ACK 给服务器端 。这称为第三次握手</li>
<li>服务器端收到 ACK 帧后 ，会把请求方从 SYN 队列中移出 ，放至 ACCEPT 队列中 ，而 accept 函数也等到了自己的资源 ，从阻塞中唤醒 ，从 ACCEPT 队列中取出请求方 ，重新建立一个新的 sockfd ，并返回 。</li>
</ol>
<p>这就是 listen,accept,connect 这三个函数的工作流程及原理 。从这个过程可以看到 ，在 connect 函数中发生了两次握手 。</p>
<p>更加详细的 accept 建立连接流程及原理请移步下面这个博文 ，该博文博主是个大牛 ，讲解的通熟易懂并且有深度：</p>
<p><a href="http://blog.csdn.net/russell_tao/article/details/9111769" target="_blank" rel="noopener">http://blog.csdn.net/russell_tao/article/details/9111769</a></p>
<h2 id="3-7-、发送消息接口"><a href="#3-7-、发送消息接口" class="headerlink" title="3.7 、发送消息接口"></a>3.7 、发送消息接口</h2><p>#include &lt;unistd.h&gt;</p>
<p>ssize_t write(int fd, const void *buf, size_t count);</p>
<p>#include &lt;sys/types.h&gt;<br>#include &lt;sys/socket.h&gt;</p>
<p>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</p>
<p>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);</p>
<p>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</p>
<p>这几个接口都比较好理解 ，查一下 man pages 就知道什么含义了 ，man pages 中讲解的非常清楚 。这里只说一下 flags 参数 ，也是摘抄自 man pages 。</p>
<p><strong>flags:</strong></p>
<ul>
<li>MSG_DONTWAIT (since Linux 2.2) ，不阻塞</li>
</ul>
<p>Enables nonblocking operation; if the operation would block, EAGAIN or EWOULDBLOCK is returned (this can also be enabled using<br>the O_NONBLOCK flag with the F_SETFL fcntl(2)).</p>
<ul>
<li>MSG_DONTROUTE ，数据包不允许通过网关</li>
</ul>
<p>Don’t use a gateway to send out the packet, only send to hosts on directly connected networks. This is usually used only by<br>diagnostic or routing programs. This is only defined for protocol families that route; packet sockets don’t.</p>
<ul>
<li>MSG_OOB ，带外数据</li>
</ul>
<p>Sends out-of-band data on sockets that support this notion (e.g., of type SOCK_STREAM); the underlying protocol must also sup‐<br>port out-of-band data.</p>
<ul>
<li>其他</li>
</ul>
<h2 id="3-8-、接受消息接口"><a href="#3-8-、接受消息接口" class="headerlink" title="3.8 、接受消息接口"></a>3.8 、接受消息接口</h2><p>#include &lt;unistd.h&gt;</p>
<p>ssize_t read(int fd, void *buf, size_t count);</p>
<p>#include &lt;sys/types.h&gt;<br>#include &lt;sys/socket.h&gt;</p>
<p>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</p>
<p>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</p>
<p>ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</p>
<p>这几个接口都比较好理解 ，查一下 man pages 就知道什么含义了 ，man pages 中讲解的非常清楚 。</p>
<h1 id="4-、socket-编程流程及-tcp-状态变迁"><a href="#4-、socket-编程流程及-tcp-状态变迁" class="headerlink" title="4 、socket 编程流程及 tcp 状态变迁"></a>4 、socket 编程流程及 tcp 状态变迁</h1><p>先做一个说明 ，下面的图都不是原创 ，是本人收藏已久的一些原理图 ，来源已经不记得了 ，如果大家知道来源的可以留言 。</p>
<p>socket 编程的一般模型是固定的 ，下面我就以几幅图来说明 ，由于插图中已经有说明 ，我就不在做补充说明了 。</p>
<h2 id="4-1-c-s-模式之-TCP"><a href="#4-1-c-s-模式之-TCP" class="headerlink" title="4.1 c/s 模式之 TCP"></a>4.1 c/s 模式之 TCP</h2><p>　<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160107201721075-1061362000.png" alt="">)<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160107202442450-451372966.png" alt=""></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图 8 c/s 模型 tcp 编程流程图及 tcp 状态变迁图</p>
<h2 id="4-2-c-s-模式之-UDP"><a href="#4-2-c-s-模式之-UDP" class="headerlink" title="4.2 c/s 模式之 UDP"></a>4.2 c/s 模式之 UDP</h2><p><img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160107203736371-2068566086.png" alt="">)<img src="https://images2015.cnblogs.com/blog/733402/201601/733402-20160107203757481-2030859869.png" alt=""></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　  图 9 c/s 模型 udp 编程流程图</p>
<p><strong>参考资料：</strong></p>
<p>《tcp/ip 协议详解卷一 、卷二》</p>
<p><a href="http://blog.csdn.net/liuxingen/article/details/44995467" target="_blank" rel="noopener">socket 函数的 domain 、type 、protocol 解析</a></p>
<p><a href="http://blog.csdn.net/qiuchangyong/article/details/50099927" target="_blank" rel="noopener">创建 socket 函数的第三个参数的意义</a></p>
<p><a href="http://blog.csdn.net/russell_tao/article/details/9111769" target="_blank" rel="noopener">陶辉：</a> <a href="http://blog.csdn.net/russell_tao/article/details/9111769" target="_blank" rel="noopener">高性能网络编程 （一） —-accept 建立连接</a></p>
<p><a href="http://blog.163.com/clevertanglei900@126/blog/static/111352259201122142545411/" target="_blank" rel="noopener">什么是带外数据</a></p>
<p><a href="http://blog.csdn.net/hguisu/article/details/7445768" target="_blank" rel="noopener">Linux 的 SOCKET 编程详解</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/08/annotation/" rel="prev" title="'annotation之@Autowired、@Inject、@Resource三者区别'">
                'annotation之@Autowired、@Inject、@Resource三者区别' <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="Stormling" />
            
              <p class="site-author-name" itemprop="name">Stormling</p>
              <p class="site-description motion-element" itemprop="description">javaer fish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-、什么是-socket"><span class="nav-number">1.</span> <span class="nav-text">1 、什么是 socket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-、具体-socket-实例如何标识"><span class="nav-number">2.</span> <span class="nav-text">2 、具体 socket 实例如何标识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-、socket-编程接口"><span class="nav-number">3.</span> <span class="nav-text">3 、socket 编程接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-、socket-接口"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 、socket 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-、bind-接口"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 、bind 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-、connect-接口"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 、connect 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-、listen-接口"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 、listen 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-、accept-接口"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 、accept 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-、listen-、connect-、accept-流程及原理"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 、listen 、connect 、accept 流程及原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-、发送消息接口"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 、发送消息接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-、接受消息接口"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 、接受消息接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-、socket-编程流程及-tcp-状态变迁"><span class="nav-number">4.</span> <span class="nav-text">4 、socket 编程流程及 tcp 状态变迁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-c-s-模式之-TCP"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 c/s 模式之 TCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-c-s-模式之-UDP"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 c/s 模式之 UDP</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stormling</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("6raE5sz08AWTxJseqEkbEmgd-gzGzoHsz", "hWCiUxqJQ4MVfQTO8QHYIgea");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
