<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java系列（八）| Java集合 | 码农Stormling</title><meta name="author" content="stormling"><meta name="copyright" content="stormling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Java核心技术 集合类Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection 接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。 Collection 接口关系图具体实现：List、Queue、Set，可以看下Collection关系图  Map 键值对关系图具体实现：Hashtable、LinkedHashMap、TreeMap，可以看下Map">
<meta property="og:type" content="article">
<meta property="og:title" content="Java系列（八）| Java集合">
<meta property="og:url" content="http://www.stormling.top/posts/19057.html">
<meta property="og:site_name" content="码农Stormling">
<meta property="og:description" content="Java核心技术 集合类Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 Collection 接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。 Collection 接口关系图具体实现：List、Queue、Set，可以看下Collection关系图  Map 键值对关系图具体实现：Hashtable、LinkedHashMap、TreeMap，可以看下Map">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/12/20/amYrZ8iHkvMtXRP.png">
<meta property="article:published_time" content="2021-12-25T06:22:03.000Z">
<meta property="article:modified_time" content="2025-01-07T15:37:31.879Z">
<meta property="article:author" content="stormling">
<meta property="article:tag" content="Java集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/12/20/amYrZ8iHkvMtXRP.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="http://www.stormling.top/posts/19057.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java系列（八）| Java集合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-color: #efefef;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.jpg" onerror="onerror=null;src='/images/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Java"><i class="fa-fw fas fa-coffee"></i><span> Java</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-spring"></i><span> Spring全家桶</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring"><i class="fa-fw fas fa-spring"></i><span> Spring</span></a></li><li><a class="site-page child" href="/categories/SpringBoot"><i class="fa-fw fas fa-spring-boot"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/SpringCloud"><i class="fa-fw fas fa-spring-cloud"></i><span> SpringCloud</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/JVM"><i class="fa-fw fas fa-cogs"></i><span> JVM</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 源码</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Mybatis"><span> Mybatis</span></a></li><li><a class="site-page child" href="/categories/HashMap"><span> HashMap</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> 互联网电子书汇总</span></a></li><li><a class="site-page child" href="/compass/"><i class="fa-fw fas fa-compass"></i><span> JAVA八股文指南</span></a></li><li><a class="site-page child" href="/history/"><i class="fa-fw fas fa-book-open"></i><span> 历史</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2024/12/20/amYrZ8iHkvMtXRP.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.jpg" alt="Logo"><span class="site-name">码农Stormling</span></a><a class="nav-page-title" href="/"><span class="site-name">Java系列（八）| Java集合</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/Java"><i class="fa-fw fas fa-coffee"></i><span> Java</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-spring"></i><span> Spring全家桶</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Spring"><i class="fa-fw fas fa-spring"></i><span> Spring</span></a></li><li><a class="site-page child" href="/categories/SpringBoot"><i class="fa-fw fas fa-spring-boot"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/SpringCloud"><i class="fa-fw fas fa-spring-cloud"></i><span> SpringCloud</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/JVM"><i class="fa-fw fas fa-cogs"></i><span> JVM</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 源码</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Mybatis"><span> Mybatis</span></a></li><li><a class="site-page child" href="/categories/HashMap"><span> HashMap</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> 互联网电子书汇总</span></a></li><li><a class="site-page child" href="/compass/"><i class="fa-fw fas fa-compass"></i><span> JAVA八股文指南</span></a></li><li><a class="site-page child" href="/history/"><i class="fa-fw fas fa-book-open"></i><span> 历史</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java系列（八）| Java集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-25T06:22:03.000Z" title="发表于 2021-12-25 14:22:03">2021-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-07T15:37:31.879Z" title="更新于 2025-01-07 23:37:31">2025-01-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/">Java 核心技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离上次更新已经&quot;,&quot;messageNext&quot;:&quot;天了，文章内容可能已经过时。&quot;,&quot;postUpdate&quot;:&quot;2025-01-07 23:37:31&quot;}" hidden></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="Java核心技术-集合类"><a href="#Java核心技术-集合类" class="headerlink" title="Java核心技术 集合类"></a>Java核心技术 集合类</h2><p><code>Java</code> 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p>
<h2 id="Collection-接口关系图"><a href="#Collection-接口关系图" class="headerlink" title="Collection 接口关系图"></a>Collection 接口关系图</h2><p>具体实现：<code>List</code>、<code>Queue</code>、<code>Set</code>，可以看下<code>Collection</code>关系图</p>
<p><a target="_blank" rel="noopener" href="https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/2025/01/20250107230336720.png" title="image-20250107162007452" class="gallery-item"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/2025/01/20250107230336720.png" alt="image-20250107162007452"></a></p>
<h2 id="Map-键值对关系图"><a href="#Map-键值对关系图" class="headerlink" title="Map 键值对关系图"></a>Map 键值对关系图</h2><p>具体实现：<code>Hashtable</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>，可以看下<code>Map</code> 关系图</p>
<p><a target="_blank" rel="noopener" href="https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/2025/01/20250107230342470.png" title="image-20250107162107726" class="gallery-item"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/2025/01/20250107230342470.png" alt="image-20250107162107726"></a> </p>
<h2 id="1-List、Set、Queue、Map-区别"><a href="#1-List、Set、Queue、Map-区别" class="headerlink" title="1.List、Set、Queue、Map 区别"></a>1.List、Set、Queue、Map 区别</h2><ul>
<li><code>List</code>：有序列表，可重复</li>
<li><code>Set</code>：无序列表，不可重复</li>
<li><code>Queue</code>：特性的排队顺序确定先后关系，存储元素是有序的，可重复</li>
<li><code>Map</code>：使用键值对（key-value）存储</li>
</ul>
<h2 id="2-List、Set、Map-常用集合有哪些？"><a href="#2-List、Set、Map-常用集合有哪些？" class="headerlink" title="2.List、Set、Map 常用集合有哪些？"></a>2.List、Set、Map 常用集合有哪些？</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h3><ul>
<li><strong>vector：</strong> 底层是数组，方法加了 <code>synchronized</code> 来保证线程安全，所以效率较慢，使用 <code>ArrayList</code> 替代。  </li>
<li><strong>ArrayList：</strong> 线程不安全，底层是数组，因为数组都是连续的地址，所以查询比较快。增删比较慢，增会生成一个新数组，把新增的元素和原有元素放到新数组中，删除会导致元素移动，所以增删速度较慢。  </li>
<li><strong>LinkedList：</strong> 线程不安全，底层是链表，因为地址不是连续的，都是一个节点和一个节点相连，每次查询都得重头开始查询，所以查询慢，增删只是断裂某个节点对整体影响不大，所以增删速度较快。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><strong>HashSet：</strong> 底层是哈希表 (数组 + 链表或数组 + 红黑树)，在链表长度大于 8 时转为红黑树，在红黑树节点小于 6 时转为链表。其实就是实现了 <code>HashMap</code>，值存入 <code>key，value</code> 是一个 <code>final</code> 修饰的对象。  </li>
<li><strong>TreeSet：</strong> 底层是红黑树结构，就是 <strong>TreeMap</strong> 实现，可以实现有序的集合。<strong>String</strong> 和 <strong>Integer</strong> 可以根据值进行排序。如果是对象需要实现 Comparator 接口，重写 compareTo() 方法制定比较规则。  </li>
<li><strong>LinkedHashSet：</strong> 实现了 <strong>HashSet</strong>，多一条链表来记录位置，所以是有序的。</li>
</ul>
<h3 id="Map-lt-key-value-gt-双例结构"><a href="#Map-lt-key-value-gt-双例结构" class="headerlink" title="Map&lt;key,value&gt; 双例结构"></a><strong>Map&lt;key,value&gt; 双例结构</strong></h3><ul>
<li><strong>TreeMap：</strong> 底层是红黑树，key 可以按顺序排列。  </li>
<li><strong>HashMap：</strong> 底层是哈希表，可以很快的储存和检索，无序，大量迭代情况不佳。  </li>
<li><strong>LinkedHashMap：</strong> 底层是哈希表 + 链表，有序，大量迭代情况佳。</li>
</ul>
<h2 id="3-ArrayList-的初始容量是多少？扩容机制是什么？扩容过程是怎样？"><a href="#3-ArrayList-的初始容量是多少？扩容机制是什么？扩容过程是怎样？" class="headerlink" title="3.ArrayList 的初始容量是多少？扩容机制是什么？扩容过程是怎样？"></a>3.ArrayList 的初始容量是多少？扩容机制是什么？扩容过程是怎样？</h2><ul>
<li><p><strong>初始容量：</strong> 默认 10，也可以通过构造方法传入大小。</p>
</li>
<li><p><strong>扩容机制：</strong> 原数组长度 + 原数组长度 / 2 (源码中是原数组右移一位，也就相当于除以 2)<br>注意：扩容后的 <strong>ArrayList</strong> 底层数组<strong>不是原来的数组</strong>。</p>
</li>
<li><p><strong>扩容过程：</strong> 因为 <strong>ArrayList</strong> 底层是数组，所以它的扩容机制和数组一样，首先新建一个新数组，长度是原数组的 <strong>1.5</strong> 倍，然后调用 <strong>Arrays.copyof()</strong> 复制原数组的值，然后赋值给新数组。</p>
</li>
</ul>
<h2 id="4-什么是哈希表"><a href="#4-什么是哈希表" class="headerlink" title="4. 什么是哈希表"></a>4. 什么是哈希表</h2><p>​    根据关键码值 (<strong>Key value</strong>) 而直接进行访问的数据结构，在一个表中，通过 **H(key)<strong>计算出 <strong>key</strong> 在表中的位置，</strong>H(key)**就是哈希函数，表就是哈希表。</p>
<h2 id="5-什么是哈希冲突"><a href="#5-什么是哈希冲突" class="headerlink" title="5. 什么是哈希冲突"></a>5. 什么是哈希冲突</h2><p>​    不同的 <strong>key</strong> 通过哈希函数计算出<strong>相同的储存地址</strong>，这就是哈希冲突。</p>
<h2 id="6-解决哈希冲突"><a href="#6-解决哈希冲突" class="headerlink" title="6. 解决哈希冲突"></a>6. 解决哈希冲突</h2><ul>
<li>开放地址法：如果发生哈希冲突，就会以当前地址为基准，再去寻找计算另一个位置，直到不发生哈希冲突。 寻找的方法有：</li>
</ul>
<ol>
<li> 线性探测 1，2，3，m  </li>
<li> 二次探测 1 的平方，-1 的平方，2 的平方，-2 的平方，k 的平方，-k 的平方，k&lt;=m/2  </li>
<li> 随机探测 生成一个随机数，然后从随机地址 + 随机数 ++。</li>
</ol>
<ul>
<li><p><strong>链地址法</strong> ：冲突的哈希值，连到到同一个链表上。</p>
</li>
<li><p><strong>再哈希法 (再散列方法)</strong>  ：多个哈希函数，发生冲突，就在用另一个算计，直到没有冲突。</p>
</li>
<li><p><strong>建立公共溢出区</strong> ：哈希表分成基本表和溢出表，与基本表发生冲突的都填入溢出表。</p>
</li>
</ul>
<h2 id="7-HashMap-的-hash-算法，为什么不是-h-key-hashcode-而是-key-hashcode-h-gt-gt-gt-16"><a href="#7-HashMap-的-hash-算法，为什么不是-h-key-hashcode-而是-key-hashcode-h-gt-gt-gt-16" class="headerlink" title="7.HashMap 的 hash() 算法，为什么不是 h=key.hashcode(), 而是 key.hashcode()^ (h&gt;&gt;&gt;16)"></a>7.HashMap 的 hash() 算法，为什么不是 h=key.hashcode(), 而是 key.hashcode()^ (h&gt;&gt;&gt;16)</h2><p>​    得到哈希值然后右移 16 位，然后进行异或运算，这样使哈希值的低 16 位也具有了一部分高 16 位的特性，增加更多的变化性，减少了哈希冲突。</p>
<h2 id="8-为什么-HashMap-的初始容量和扩容都是-2-的次幂"><a href="#8-为什么-HashMap-的初始容量和扩容都是-2-的次幂" class="headerlink" title="8. 为什么 HashMap 的初始容量和扩容都是 2 的次幂"></a>8. 为什么 HashMap 的初始容量和扩容都是 2 的次幂</h2><p>​    因为计算元素存储的下标是 (n-1)&amp; 哈希值，数组初始容量 -1，得到的二进制都是 1，这样可以减少哈希冲突，可以更好的均匀插入。</p>
<h2 id="9-HashMap-如果指定了不是-2-的次幂的容量会发生什么？"><a href="#9-HashMap-如果指定了不是-2-的次幂的容量会发生什么？" class="headerlink" title="9.HashMap 如果指定了不是 2 的次幂的容量会发生什么？"></a>9.HashMap 如果指定了不是 2 的次幂的容量会发生什么？</h2><p>​    会获得一个大于指定的初始值的最接近 2 的次幂的值作为初始容量。</p>
<h2 id="10-HashMap-为什么线程不安全"><a href="#10-HashMap-为什么线程不安全" class="headerlink" title="10.HashMap 为什么线程不安全"></a>10.HashMap 为什么线程不安全</h2><ul>
<li> <strong>jdk1.7</strong> 中因为使用<strong>头插法</strong>，再扩容的时候，可能会造成<strong>闭环和数据丢失</strong>。 </li>
<li><strong>jdk1.8</strong> 中使用<strong>尾插法</strong>，不会出现闭环和数据丢失，但是在多线程下，会<strong>发生数据覆盖</strong>。<ul>
<li><strong>put</strong> 操作中，在 <strong>putVal</strong> 函数里，<strong>值的覆盖还有长度的覆盖</strong>。</li>
</ul>
</li>
</ul>
<h2 id="11-解决-Hashmap-的线程安全问题"><a href="#11-解决-Hashmap-的线程安全问题" class="headerlink" title="11. 解决 Hashmap 的线程安全问题"></a>11. 解决 Hashmap 的线程安全问题</h2><p>​    (1) 使用 <code>Hashtable</code> 解决，在方法加同步关键字，所以<strong>效率低下</strong>，已经被弃用。<br>​    (2) 使用 <code>Collections.synchronizedMap(new HashMap&lt;&gt;()),</code> 不常用。<br>​    (3)<code>ConcurrentHashMap</code>(常用)</p>
<h2 id="12-ConcurrentHashMap-的原理"><a href="#12-ConcurrentHashMap-的原理" class="headerlink" title="12.ConcurrentHashMap 的原理"></a>12.ConcurrentHashMap 的原理</h2><ul>
<li><strong>jdk1.7：</strong> 采用<strong>分段锁</strong>，是由 <code>Segment</code>(继承 <code>ReentrantLock</code>：可重入锁，默认是 16，并发度是 16) 和 <code>HashEntry</code> 内部类组成，每一个 <code>Segment</code>(锁) 对应 1 个 <code>HashEntry(key，value)</code> 数组，数组之间互不影响，实现了并发访问。  </li>
<li><strong>jdk1.8：</strong> 抛弃分段锁，采用 <strong>CAS(乐观锁)+synchronized</strong> 实现更加<strong>细粒度的锁</strong>，【<strong>Node 数组 + 链表 + 红黑树</strong>】结构。只要锁住链表的<strong>头节点</strong> (树的根节点)，就不会影响其他数组的读写，提高了并发度。</li>
</ul>
<h2 id="13-为什么用-synchronized-代替-ReentrantLock"><a href="#13-为什么用-synchronized-代替-ReentrantLock" class="headerlink" title="13. 为什么用 synchronized 代替 ReentrantLock"></a>13. 为什么用 synchronized 代替 ReentrantLock</h2><p>​    ①节省内存开销。<code>ReentrantLock</code> 基于 <code>AQS</code> 来获得同步支持，但不是每个节点都需要同步支持，只有<strong>链表头节点</strong>或<strong>树的根节点</strong>需要同步，所以使用 <code>ReentrantLock</code> 会带来很大的<strong>内存开销</strong>。<br>​    ②获得 <code>jvm</code> 支持，可重入锁只是 <code>api</code> 级别，而 <code>synchronized</code> 是 <code>jvm</code> 直接支持的，能够在 <code>jvm</code> 运行时做出相应的优化。<br>​    ③在 <code>jdk1.6</code> 之后，对 <code>synchronized</code> 做了大量的优化，而且有<strong>多种锁状态</strong>，会从 【<strong>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</strong>】一步步转换。</p>
<p>​    <strong>AQS (Abstract Queued Synchronizer)：</strong> 一个<strong>抽象的队列同步器</strong>，通过维护一个共享资源状态（ <strong>Volatile Int State</strong> ）和一个先进先出（ <strong>FIFO</strong> ）的线程等待队列来实现一个多线程访问共享资源的<strong>同步框架</strong>。</p>
<h2 id="14-HashMap-为什么使用链表"><a href="#14-HashMap-为什么使用链表" class="headerlink" title="14.HashMap 为什么使用链表"></a>14.HashMap 为什么使用链表</h2><p>​    减少和解决哈希冲突，把冲突的值放在同一链表下。</p>
<h2 id="15-HashMap-为什么使用红黑树"><a href="#15-HashMap-为什么使用红黑树" class="headerlink" title="15.HashMap 为什么使用红黑树"></a>15.HashMap 为什么使用红黑树</h2><p>​    当数据过多，链表遍历较慢，所以引入红黑树。</p>
<h2 id="16-HashMap-为什么不一上来就使用红黑树"><a href="#16-HashMap-为什么不一上来就使用红黑树" class="headerlink" title="16.HashMap 为什么不一上来就使用红黑树"></a>16.HashMap 为什么不一上来就使用红黑树</h2><p>​    维护成本较大，红黑树在插入新的数据后，可能会进行【<strong>变色、左旋、右旋</strong>】来保持平衡，所以当数据少时，就不需要红黑树。</p>
<h2 id="17-说说你对红黑树的理解-❕❕需要扩展"><a href="#17-说说你对红黑树的理解-❕❕需要扩展" class="headerlink" title="17. 说说你对红黑树的理解(❕❕需要扩展)"></a>17. 说说你对红黑树的理解(❕❕需要扩展)</h2><p>​    ①根节点是黑色。</p>
<p>​    ②节点是黑色或红色。</p>
<p>​    ③叶子节点是黑色。</p>
<p>​    ④红色节点的子节点都是黑色。 </p>
<p>​    ⑤从任意节点到其子节点的所有路径都包含相同数目的黑色节点。 </p>
<p><strong>红黑树从根到叶子节点的最长路径不会超过最短路径的 2 倍。保证了红黑树的高效。</strong></p>
<h2 id="18-为什么链表长度大于-8，并且表的长度大于-64-的时候，链表会转换成红黑树？"><a href="#18-为什么链表长度大于-8，并且表的长度大于-64-的时候，链表会转换成红黑树？" class="headerlink" title="18. 为什么链表长度大于 8，并且表的长度大于 64 的时候，链表会转换成红黑树？"></a>18. 为什么链表长度大于 8，并且表的长度大于 64 的时候，链表会转换成红黑树？</h2><p>​    因为链表长度越长，哈希冲突概率就越小，当链表等于 8 时，哈希冲突就非常低了，是千万分之一，我们的 <code>map</code> 也不会存那么多数据，如果真要存那么多数据，那就转为红黑树，提高<strong>查询和插入</strong>的效率。</p>
<h2 id="19-为什么转成红黑树是-8-呢？而重新转为链表阈值是-6-呢？"><a href="#19-为什么转成红黑树是-8-呢？而重新转为链表阈值是-6-呢？" class="headerlink" title="19. 为什么转成红黑树是 8 呢？而重新转为链表阈值是 6 呢？"></a>19. 为什么转成红黑树是 8 呢？而重新转为链表阈值是 6 呢？</h2><p>​    因为如果都是 8 的话，那么会<strong>频繁转换，会浪费资源</strong>。</p>
<h2 id="20-为什么负载因子是-0-75？-冲突和利用率"><a href="#20-为什么负载因子是-0-75？-冲突和利用率" class="headerlink" title="20. 为什么负载因子是 0.75？(冲突和利用率)"></a>20. 为什么负载因子是 0.75？(冲突和利用率)</h2><p>​    加载因子越大，<strong>填满的元素越多</strong>，<strong>空间利用率越高</strong>，但发生冲突的机会变大了； </p>
<p>​    加载因子越小，填满的元素越少，<strong>冲突发生的机会减小</strong>，但<strong>空间浪费</strong>了更多了，而且还会提高扩容 <strong>rehash</strong> 操作的次数。  </p>
<p>​    “冲突的机会”与 “空间利用率” 之间，寻找一种平衡与折中。 </p>
<p>​    又因为根据<strong>泊松分布</strong>，当负载因子是 0.75 时，平均值是 0.5，带入可得，当链表为 8 时，哈希冲突发生概率就很低了。</p>
<h2 id="21-什么时候会扩容？"><a href="#21-什么时候会扩容？" class="headerlink" title="21. 什么时候会扩容？"></a>21. 什么时候会扩容？</h2><p>​    元素个数 &gt; 数组长度 * 负载因子 例如 16 * 0.75 = 12, 当元素超过 12 个时就会扩容。<br>​    链表长度大于 8 并且表长小于 64，也会扩容</p>
<h2 id="22-为什么不是满了扩容？"><a href="#22-为什么不是满了扩容？" class="headerlink" title="22. 为什么不是满了扩容？"></a>22. 为什么不是满了扩容？</h2><p>​    因为元素越多，空间利用率是高了，但是发生哈希<strong>冲突</strong>的几率也<strong>增加</strong>了。</p>
<h2 id="23-扩容过程"><a href="#23-扩容过程" class="headerlink" title="23. 扩容过程"></a>23. 扩容过程</h2><ul>
<li><strong>jdk1.7：</strong> 会生成一个新 <code>table</code>，重新计算每个节点放进新 <code>table</code>，因为是<strong>头插法</strong>，在线程不安全的时候，可能会<strong>出现闭环和数据丢失</strong>。  </li>
<li><strong>jdk1.8：</strong> 会生成一个新 <code>table</code>，新位置只需要看 <code>(e.hash &amp; oldCap)</code> 结果是 0 还是 1；0 就放在旧下标，1 就是旧下标 + 旧数组长度。避免了对每个节点进行 hash 计算，大大提高了效率。<strong>e.hash</strong> 是数组的 <strong>hash</strong> 值，，<strong>oldCap</strong> 是旧数组的长度。</li>
</ul>
<h2 id="24-HashMap-和-Hashtable-的区别"><a href="#24-HashMap-和-Hashtable-的区别" class="headerlink" title="24.HashMap 和 Hashtable 的区别"></a>24.HashMap 和 Hashtable 的区别</h2><table>
<thead>
<tr>
<th>HashTable</th>
<th>HashMap</th>
</tr>
</thead>
<tbody><tr>
<td>Key Value 不能 null</td>
<td>Key Value 可为 null</td>
</tr>
<tr>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<h2 id="25-集合为什么要用迭代器-Iterator"><a href="#25-集合为什么要用迭代器-Iterator" class="headerlink" title="25. 集合为什么要用迭代器 (Iterator)"></a>25. 集合为什么要用迭代器 (Iterator)</h2><p>​    更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。<br>如果不用迭代器，只能 for 循环，还必须知道集合的数据结构，复用性不强。</p>
<h2 id="参考自："><a href="#参考自：" class="headerlink" title="参考自："></a>参考自：</h2><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/128424569?spm=1001.2014.3001.5502">java 集合框架详解</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/128426417?spm=1001.2014.3001.5502">HashMap 底层原理详解</a></strong></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.stormling.top">stormling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.stormling.top/posts/19057.html">http://www.stormling.top/posts/19057.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://www.stormling.top" target="_blank">码农Stormling</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9B%86%E5%90%88/">Java集合</a></div><div class="post-share"><div class="social-share" data-image="https://s2.loli.net/2024/12/20/amYrZ8iHkvMtXRP.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/19057.html" title="Java系列（九）| Java多线程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/12/18/ipgJehsTy7L38fV.webp" onerror="onerror=null;src='/images/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java系列（九）| Java多线程</div></div><div class="info-2"><div class="info-item-1">多线程java 多线程及线程池原理讲解 1. 线程是什么？多线程是什么？​    线程： 是最小的调度单位，包含在进程中。​    多线程： 多个线程并发执行的技术。 2. 守护线程和用户线程守护线程： jvm 给的线程。比如：GC 守护线程。  用户线程： 用户自己定义的线程。比如：main() 线程。 拓展：  Thread.setDaemon(false) 设置为用户线程   Thread.setDaemon(true) 设置为守护线程  3. 线程的各个状态 新建 (New): 新建一个线程。 就绪 (Runnable): 抢夺 cpu 的使用权。   运行 (Running): 开始执行任务。   阻塞 (Blocked)： 让线程等待，等待结束进入就绪队列。   死亡 (Dead)： 线程正常结束或异常结束。  4. 线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等 wait()： 线程等待，会释放锁，用于同步代码块或同步方法中，进入等待状态   sleep()： 线程睡眠，不会释放锁，进入超时等待状态 ...</div></div></div></a><a class="pagination-related" href="/posts/14054.html" title="网络系列（一）| TCP 快速入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/12/19/dNugUCRYX27ePwS.jpg" onerror="onerror=null;src='/images/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">网络系列（一）| TCP 快速入门</div></div><div class="info-2"><div class="info-item-1">简介互联网有一整套协议构成，TCP是其中的一层   以太网 作用：电子信号如何组成数据包（packet），解决了子网内部点对点通信 缺点：无法连接多个局域网，IP协议解决  IP 作用：定义一套自己的地址规则，通过路由的形式将各个局域网相连。路由器基于IP协议 路由器内部有一张路由表，规定 IP 出口，实现数据包转发 缺点：是地址协议，不能保证数据完整，TCP 协议解决  TCP 作用： 保证数据通信的完整性和可靠性，防止丢包  TCP 数据包以太网的数据包 大小固定，最初1518 增加到 1522 字节 。其中头信息（head）22 字节，负载（payload）：1500字节  以太网数据包：1522 字节  头信息：22 负载：1500 IP数据包 头信息：20（最少） 负载：1480 TCP 数据包 头信息：20 （最少） 负载：1400           TCP 数据包编号（SEQ）TCP 为每个数据包编号（sequence number），目的是为了接收方按照顺序还原。另外，万一丢包也可知道丢失哪一个包。 每个数据包都有两个编号  自身编号：sequence...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/images/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">stormling</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lingzhexi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://gitee.com/lingzhexi" target="_blank" title="Gitee"><i class="fab fa-gitee" style="color: #e94f11;"></i></a><a class="social-icon" href="https://github.com/lingzhexi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lingzhexi@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎大家来到Stormling博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Java核心技术 集合类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">Collection 接口关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E9%94%AE%E5%80%BC%E5%AF%B9%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">Map 键值对关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-List%E3%80%81Set%E3%80%81Queue%E3%80%81Map-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">1.List、Set、Queue、Map 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-List%E3%80%81Set%E3%80%81Map-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">2.List、Set、Map 常用集合有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">5.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">5.2.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-lt-key-value-gt-%E5%8F%8C%E4%BE%8B%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.</span> <span class="toc-text">Map&lt;key,value&gt; 双例结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ArrayList-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">3.ArrayList 的初始容量是多少？扩容机制是什么？扩容过程是怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">4. 什么是哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">8.</span> <span class="toc-text">5. 什么是哈希冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">9.</span> <span class="toc-text">6. 解决哈希冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-HashMap-%E7%9A%84-hash-%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-h-key-hashcode-%E8%80%8C%E6%98%AF-key-hashcode-h-gt-gt-gt-16"><span class="toc-number">10.</span> <span class="toc-text">7.HashMap 的 hash() 算法，为什么不是 h&#x3D;key.hashcode(), 而是 key.hashcode()^ (h&gt;&gt;&gt;16)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E5%92%8C%E6%89%A9%E5%AE%B9%E9%83%BD%E6%98%AF-2-%E7%9A%84%E6%AC%A1%E5%B9%82"><span class="toc-number">11.</span> <span class="toc-text">8. 为什么 HashMap 的初始容量和扩容都是 2 的次幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-HashMap-%E5%A6%82%E6%9E%9C%E6%8C%87%E5%AE%9A%E4%BA%86%E4%B8%8D%E6%98%AF-2-%E7%9A%84%E6%AC%A1%E5%B9%82%E7%9A%84%E5%AE%B9%E9%87%8F%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">9.HashMap 如果指定了不是 2 的次幂的容量会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">13.</span> <span class="toc-text">10.HashMap 为什么线程不安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%A7%A3%E5%86%B3-Hashmap-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">14.</span> <span class="toc-text">11. 解决 Hashmap 的线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-ConcurrentHashMap-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">12.ConcurrentHashMap 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-synchronized-%E4%BB%A3%E6%9B%BF-ReentrantLock"><span class="toc-number">16.</span> <span class="toc-text">13. 为什么用 synchronized 代替 ReentrantLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8"><span class="toc-number">17.</span> <span class="toc-text">14.HashMap 为什么使用链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">18.</span> <span class="toc-text">15.HashMap 为什么使用红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-HashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%B8%80%E4%B8%8A%E6%9D%A5%E5%B0%B1%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">19.</span> <span class="toc-text">16.HashMap 为什么不一上来就使用红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%90%86%E8%A7%A3-%E2%9D%95%E2%9D%95%E9%9C%80%E8%A6%81%E6%89%A9%E5%B1%95"><span class="toc-number">20.</span> <span class="toc-text">17. 说说你对红黑树的理解(❕❕需要扩展)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E-8%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E-64-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%93%BE%E8%A1%A8%E4%BC%9A%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">18. 为什么链表长度大于 8，并且表的长度大于 64 的时候，链表会转换成红黑树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BD%AC%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF-8-%E5%91%A2%EF%BC%9F%E8%80%8C%E9%87%8D%E6%96%B0%E8%BD%AC%E4%B8%BA%E9%93%BE%E8%A1%A8%E9%98%88%E5%80%BC%E6%98%AF-6-%E5%91%A2%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">19. 为什么转成红黑树是 8 呢？而重新转为链表阈值是 6 呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E6%98%AF-0-75%EF%BC%9F-%E5%86%B2%E7%AA%81%E5%92%8C%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">23.</span> <span class="toc-text">20. 为什么负载因子是 0.75？(冲突和利用率)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">21. 什么时候会扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E6%BB%A1%E4%BA%86%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">22. 为什么不是满了扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">23. 扩容过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">27.</span> <span class="toc-text">24.HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E9%9B%86%E5%90%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="toc-number">28.</span> <span class="toc-text">25. 集合为什么要用迭代器 (Iterator)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%87%AA%EF%BC%9A"><span class="toc-number">29.</span> <span class="toc-text">参考自：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/46064.html" title="【每日早报】-2025-01-16 - 星期四"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://file.alapi.cn/60s/202501161736963102_head.png" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="【每日早报】-2025-01-16 - 星期四"/></a><div class="content"><a class="title" href="/posts/46064.html" title="【每日早报】-2025-01-16 - 星期四">【每日早报】-2025-01-16 - 星期四</a><time datetime="2025-01-15T16:00:00.000Z" title="发表于 2025-01-16 00:00:00">2025-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/19819.html" title="规则引擎 Drools 8+ 快速入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/12/22/4ei1fqHM3RKSUr2.webp" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="规则引擎 Drools 8+ 快速入门"/></a><div class="content"><a class="title" href="/posts/19819.html" title="规则引擎 Drools 8+ 快速入门">规则引擎 Drools 8+ 快速入门</a><time datetime="2024-12-11T00:00:00.000Z" title="发表于 2024-12-11 08:00:00">2024-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/60908.html" title="数据库系列（二） | Mybatis Plus 3.0+快速入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lingzhexi/blogImage/post/image-20240927101721314.png" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="数据库系列（二） | Mybatis Plus 3.0+快速入门"/></a><div class="content"><a class="title" href="/posts/60908.html" title="数据库系列（二） | Mybatis Plus 3.0+快速入门">数据库系列（二） | Mybatis Plus 3.0+快速入门</a><time datetime="2024-12-09T06:22:03.000Z" title="发表于 2024-12-09 14:22:03">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50356.html" title="分布式系列（二） | Redisson分布式锁"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/12/22/Q6z8bLIciZ9TuFS.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="分布式系列（二） | Redisson分布式锁"/></a><div class="content"><a class="title" href="/posts/50356.html" title="分布式系列（二） | Redisson分布式锁">分布式系列（二） | Redisson分布式锁</a><time datetime="2024-12-05T06:22:03.000Z" title="发表于 2024-12-05 14:22:03">2024-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/28724.html" title="分布式系列（一） | Redis分布式锁"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/12/22/n4qy9zw1Pj5r8Nv.jpg" onerror="this.onerror=null;this.src='/images/404.jpg'" alt="分布式系列（一） | Redis分布式锁"/></a><div class="content"><a class="title" href="/posts/28724.html" title="分布式系列（一） | Redis分布式锁">分布式系列（一） | Redis分布式锁</a><time datetime="2024-12-03T06:22:03.000Z" title="发表于 2024-12-03 14:22:03">2024-12-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://s2.loli.net/2024/12/20/amYrZ8iHkvMtXRP.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By stormling</div><div class="footer_custom_text">码农Stormling程序员,关注公众号【码农Stormling】回复【面试】获取最全面试pdf</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '49264f33fe43a9bf71c48fa3f0c0482f'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Valine' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="2426530028" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body></html>